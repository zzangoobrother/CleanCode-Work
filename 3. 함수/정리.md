# SOLID
1. SRP (단일 책임 원칙)
- 한 클래스는 하나의 책임만 가져야 한다.
- 가독성 향상과 유지보수가 용이해진다.

2. OCP (개방-폐쇄 원칙)
- 확장에는 열려 있으나 변경에는 닫혀 있다.
- 변경을 위한 비용은 줄이고, 확장을 위한 비용은 극대화 해야 한다.
- 요구사항의 변경이나 추가사항이 발생해도, 기존 구성요소에는 수정이 일어나지 않고, 쉽게 확장해서 재사용한다.
- 객체지향의 추상화와 다형성을 활용한다.

3. LSP (리스코프 치환 원칙)
- 서브 타입은 언제나 기반 타입으로 교체 가능하다.
- 클래스 상속, 인터페이스 상속을 이용해 확장성 획득
- 다형성과 확장성을 위해 인터페이스 사용이 더 좋다.

4. ISP (인터페이스 분리 원칙)
- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
- 가능한 최소한의 인터페이스만 구현
- 어떤 클래스를 이용하는 클라이언트가 여러개이고, 클래스의 특정 부분만 이용한다면, 
  여러 인터페이스로 분류하여 클라이언트가 필요한 기능만 전달
- SRP가 클래스 단일 책임이면, ISP는 인터페이스 단일 책임

5. DIP (의존성 역전 원칙)
- 상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다.


함수의 인수는 0 ~ 2개가 적당하다. 만약 3개 이상이면 객체를 만들어 인자로 넘기자

# 함수 리팩터링
- 기능을 구현하는 서투른 함수 작성, 길고 복잡하고 중복도 있고...
- 테스트 코드 작성, 함수 내부의 분기와 엣지값마다 빠짐없이 테스트 코드 작성
- 리팩터링, 코드를 다듬고, 함수를 쪼개고, 이름을 변경, 중복을 제거
